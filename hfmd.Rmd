---
title: "Hand-foot-and-mouth disease"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Constants

The data are in this folder:

```{r}
data_folder <- paste0("~/Library/CloudStorage/OneDrive-OxfordUniversityClinicalResearchUnit/",
                      "GitHub/OUCRU-Modelling/hfmd/")
```


## Packages

Make sure that all the package listed below are installed. If a package (e.g.
`tidyr`) is not installed, install it by typing `install.packages("tidyr")` at
the command line.

```{r message = FALSE}
library(readxl)
library(dplyr)
library(stringr)
library(purrr)
library(tidyr)
library(lubridate)
library(magrittr)
library(mgcv)
```


## Functions

A function that reads the excel files:

```{r}
read_excel2 <- function(x, ...) {
  out <- readxl::read_excel(paste0(data_folder, x), skip = 1, ...)
  out |>
    names() |>
    str_remove("^.*\r*\n\\(") |>
    str_remove("\\)") |>
    str_replace("...12", "month") |>
    str_replace("...13", "year") %>%
    setNames(out, .) |> 
    filter(! is.na(Participant_No))
}
```

A tuning of the `polygon()` function:

```{r}
polygon2 <- function(x, y1, y2, ...) {
  polygon(c(x, rev(x)), c(y1, rev(y2)), ...)
}
```

The function that performs a likelihood ratio test:

```{r}
lrt <- function(...) anova(..., test = "LRT")
```

A tuning of the `points()` function:

```{r}
points2 <- function(...) points(..., pch = "|", cex = .5)
```

A tuning of the `mgcv::gam()` function:

```{r}
gam2 <- function(formula, family = gaussian(), data = list(), ...){
  out <- mgcv::gam(formula, family, data, ...)
  out$data <- data
  out
} 
```

A function that extracts model quality metrics from a `gam` object:

```{r}
quality <- function(x) {
  tibble(deviance = deviance(x),
         AIC      = AIC(x),
         GCV      = x$gcv.ubre)
}
```

A function that adds a column (in first position) to a tibble to inform about
the type of smoothing that was applied:

```{r}
add_smooth_col <- function(x, s) {
  bind_cols(tibble(smooth = s), x)
}
```

A function that extracts p values from an `anova` object (run on a `gam` object):

```{r}
p_values <- function(x) {
  tibble(year     = x$p.table[2, "Pr(>|z|)"],
         "s(age)" = x$s.table[1, "p-value"])
}
```


## Loading data

```{r, message = FALSE}
sero <- data_folder |>
  dir() |> 
  map_dfr(read_excel2) |> 
  mutate(across(Neutralization, ~ .x == "Yes")) |> 
  replace_na(list(Neutralization = FALSE)) |> 
  mutate(collection_date = ymd(paste(year, month, `Day of taking blood sample`, sep = ":"))) |> 
  select(- `Day of taking blood sample`) |> 
  mutate(across(`Serum dilution`, ~ str_remove(.x, "1:") |> as.integer())) |> 
  rename(age = `Exact age calculated`, neutralization = Neutralization)
```


## A polynomial logistic model

A function that computes a model's predictions:

```{r}
predict2 <- function(x, ci = .95, le = 512, m = 100) {
  p <- (1 - ci) / 2
  
  link_inv <- x$family$linkinv
  dataset <- x$data
  n <- nrow(dataset) - length(x$coefficients)
  age_range <- range(dataset$age)
  
  ages <- seq(age_range[1], age_range[2], le = le)
  
  x |> 
    predict(data.frame(age = ages), se.fit = TRUE) |> 
    extract(c("fit", "se.fit")) %>%
    c(age = list(ages), .) |>
    as_tibble() |> 
    mutate(lwr = m * link_inv(fit + qt(    p, n) * se.fit),
           upr = m * link_inv(fit + qt(1 - p, n) * se.fit),
           fit = m * link_inv(fit)) |> 
    select(- se.fit)
}
```

A function that plots a model's predictions:

```{r}
plot_predictions <- function(x, add = FALSE, col = 4, alpha = .2, lwd = 2, m = 100) {
  with(x, {
    if (! add) {
      plot(NA, xlim = c(0, max(age)), ylim = c(0, m),
           xlab = "age (year)", ylab = "seroprevalence (%)")
    }
    polygon2(age, lwr, upr, border = NA, col = adjustcolor(col, alpha))
    lines(age, fit, col = col, lwd = lwd)
  })
}
```

A function that generates a polynomial formula:

```{r}
make_formula <- function(degree) {
  2:degree |>
    map_chr(~ paste("I(age ^", .x, ")")) |> 
    paste(collapse = " + ") %>%
    paste("neutralization ~ age +", .) |> 
    as.formula()
}
```

A function that helps looking for the optimal degree of the polynomial:

```{r}
test_degrees <- function(year, degree) {
  make_formula(degree) |> 
    glm(binomial, filter(sero, year == as.character(year))) |> 
    lrt()
}
```

Looking for optimal degrees for the 2 years:

```{r}
test_degrees(2022, 5)
test_degrees(2023, 5)
```

Looking for year effects:

```{r}
lrt(glm(neutralization ~ age * year + I(age ^2) * year, binomial, sero))
```

Best final model is then:

```{r}
m <- 100
eps <- 1

glm(neutralization ~ age + I(age ^2), binomial, filter(sero, year == "2022")) |> 
  predict2() |> 
  plot_predictions()

glm(neutralization ~ age + I(age ^2), binomial, filter(sero, year == "2023")) |> 
  predict2() |> 
  plot_predictions(add = TRUE, col = 2)

sero |>
  filter(year == "2022") |> 
  with(points2(age, m * neutralization + eps, col = 4))

sero |>
  filter(year == "2023") |> 
  with(points2(age, m * neutralization - eps, col = 2))

legend("left", legend = c("Dec 2022", "Apr 2023"), lty = 1, lwd = 2,
       col = c(4, 2), bty = "n")
```


## Generalized additive model

The list of smoothing options:

```{r}
smooths  <- c("tp", "ds", "cr", "cs", "cc", "bs", "ps", "cp", "re", "gp", "ad", "sz", "fs")
```

Looking at year and smoothed age effects for all the different types of
smoothing available:

```{r}
smooths |> 
  map_dfr(~ p_values(anova(gam(neutralization ~ s(age, bs = .x) + year,
                               binomial, sero)))) |> 
  add_smooth_col(smooths)
```

Looking at the model qualities of the different smootings options:

```{r}
smooths |>
  map_dfr(~ quality(gam(neutralization ~ s(age, bs = .x) + year,
                        binomial, sero))) |> 
  add_smooth_col(smooths)
```

Models qualities for the 2 years separately:

```{r}
smooths |>
  map_dfr(~ quality(gam(neutralization ~ s(age, bs = .x), binomial,
                        filter(sero, year == "2022")))) |> 
  add_smooth_col(smooths)

smooths |>
  map_dfr(~ quality(gam(neutralization ~ s(age, bs = .x), binomial,
                        filter(sero, year == "2023")))) |> 
  add_smooth_col(smooths)
```

The figure with a given smoothing:

```{r}
gam_figure <- function(s = "bs") {
  m <- 100
  eps <- 1
  
  gam2(neutralization ~ s(age, bs = s), binomial, filter(sero, year == "2022")) |>
    predict2() |> 
    plot_predictions()
  
  gam2(neutralization ~ s(age, bs = s), binomial, filter(sero, year == "2023")) |>
    predict2() |> 
    plot_predictions(add = TRUE, col = 2)
  
  sero |>
    filter(year == "2022") |> 
    with(points2(age, m * neutralization + eps, col = 4))
  
  sero |>
    filter(year == "2023") |> 
    with(points2(age, m * neutralization - eps, col = 2))
  
  legend("left", legend = c("Dec 2022", "Apr 2023"), lty = 1, lwd = 2,
         col = c(4, 2), bty = "n")
}
```

With B-spline:

```{r}
gam_figure(s = "bs")
```

## Modeling age and time at the same time

```{r}
sero |> 
  group_by(collection_date) |> 
  tally() |> 
  plot(type = "h", xlab = "sample collection", ylab = "number of samples", col = 4)
```

```{r}
sero |> 
  select(age, neutralization, collection_date)
```

```{r}
mod1 <- glm(neutralization ~ age * collection_date + I(age ^ 2) * collection_date,
            binomial, mutate(sero, across(collection_date, as.numeric)))
mod2 <- update(mod1, . ~ . +   age     * I(collection_date ^ 2))
mod3 <- update(mod1, . ~ . + I(age ^2) * I(collection_date ^ 2))
mod4 <- update(mod2, . ~ . + I(age ^2) * I(collection_date ^ 2))

anova(mod1, mod2, mod4)
anova(mod1, mod3, mod4)
```


A function that returns the names of the covariables from a formula:


```{r}
covariables <- function(formula) {
  formula |> 
    as.character() |> 
    last() |> 
    str_split("\\+ | \\* | \\:") |> 
    first() |>
    trimws() %>% 
    grep("^I *\\(", ., invert = TRUE, value = TRUE) |> 
    unique()
}
```

```{r}
predict3 <- function(x, ci = .95, le = 50, m = 100) {
  p <- (1 - ci) / 2
  
  link_inv <- x$family$linkinv
  dataset <- x$data
  n <- nrow(dataset) - length(x$coefficients)
  
  new_data <- dataset[covariables(mod1$formula)] |> 
    map(range) |> 
    map(~ seq(.x[1], .x[2], le = le)) %>%
    do.call(expand.grid, .)
  
  x |> 
    predict(new_data, se.fit = TRUE) |> 
    extract(c("fit", "se.fit")) |> 
    as_tibble() %>%
    bind_cols(new_data, .) |> 
    mutate(lwr = m * link_inv(fit + qt(    p, n) * se.fit),
           upr = m * link_inv(fit + qt(1 - p, n) * se.fit),
           fit = m * link_inv(fit)) |> 
    select(- se.fit)
}
```

```{r}
cvrbls <- covariables(mod1$formula)
dataset <- mod1$data
dataset[cvrbls] |> 
  map(range) |> 
  map(~ seq(.x[1], .x[2], le = le)) %>%
  do.call(expand.grid, .)
```

